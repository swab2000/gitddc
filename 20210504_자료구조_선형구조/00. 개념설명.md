# 0. 자료구조

## 개요

- 대량의 데이터를 효율적으로 관리할 수 있도록 하는 데이터의 구조
- 데이터 특성에 따라서, 체계적인 데이터 구조화가 필요
- 코드의 효율성, 성능과 밀접한 연관

## 종류

(다음주, 다다음주에 걸쳐서 학습할테니

지금은 이런 것들이 있다는 것만 알고 넘어갈게요)

1. 단순구조
   1. 정수 (int)
   2. 실수 (float)
   3. 문자 (chr)
2. 선형구조 (*이번주 학습 내용* - [그림으로 이해하기](https://visualgo.net/en/list))
   1. 순차리스트 (배열(Array), 리스트(List))
   2. 연결리스트 
      1. 단순연결리스트 (Linked List; LL)
      2. 이중연결리스트 (Doubly Linked List; DLL)
      3. 원형연결리스트 (Circular Linked List; CLL)
   3. 스택 (Stack)
   4. 큐 (Queue)
   5. 덱 (Deque)
3. 비선형구조
   1. 그래프
      1. 무향 그래프 ((Undirected) Graph) 
      2. 유향 그래프 (Direct Graph, Digraph)
      3. 가중치 그래프 (Weighted Graph)
   2. 트리
      1. 이진트리 (Binary Tree)
      2. 일반트리 (Non-Binary Tree)
4. 파일구조
   1. 순차 파일 (Sequential File)
   2. 직접 파일 (Direct File)
   3. 색인 파일 (색인 순차 파일, Indexed Sequential File) - 순차 파일 + 직접 파일

# 목차
- [0. 자료구조](#0-자료구조)
  - [개요](#개요)
  - [종류](#종류)
- [목차](#목차)
- [1. 순차리스트 (배열(Array), 리스트(List))](#1-순차리스트-배열array-리스트list)
  - [1-1. 개요](#1-1-개요)
  - [1-2. 장점](#1-2-장점)
  - [1-3. 단점](#1-3-단점)
  - [1-4. 활용](#1-4-활용)
  - [1-5. 파이썬 구현 예제](#1-5-파이썬-구현-예제)
- [2. 연결리스트 (Linked List; LL)](#2-연결리스트-linked-list-ll)
  - [2-1. 개요](#2-1-개요)
  - [2-2. 장점](#2-2-장점)
  - [2-3. 단점](#2-3-단점)
  - [2-4. 종류](#2-4-종류)
  - [2-5. 활용](#2-5-활용)
  - [2-6. 파이썬 구현 예제](#2-6-파이썬-구현-예제)
    - [2-6-1. node 구현](#2-6-1-node-구현)
    - [2-6-2. 연산 구현](#2-6-2-연산-구현)
- [3. 스택 (Stack)](#3-스택-stack)
  - [3-1. 개요](#3-1-개요)
  - [3-2. 장점](#3-2-장점)
  - [3-3. 단점](#3-3-단점)
  - [3-4. 활용](#3-4-활용)
  - [3-5. 파이썬 구현 예제](#3-5-파이썬-구현-예제)
- [4. 큐 (Queue)](#4-큐-queue)
  - [4-1. 개요](#4-1-개요)
  - [4-2. 장점](#4-2-장점)
  - [4-3. 단점](#4-3-단점)
  - [4-4. 활용](#4-4-활용)
  - [4-5. 파이썬 구현 예제](#4-5-파이썬-구현-예제)
- [5. 덱 (Deque)](#5-덱-deque)
  - [5-1. 개요](#5-1-개요)
  - [5-2. 장점](#5-2-장점)
  - [5-3. 단점](#5-3-단점)
  - [5-4. 활용](#5-4-활용)
  - [5-5. 파이썬 구현 예제](#5-5-파이썬-구현-예제)
- [99. 정리](#99-정리)
  - [99-1. 순차리스트 vs 연결리스트](#99-1-순차리스트-vs-연결리스트)
  - [99-2. 스택 vs 큐 vs 덱](#99-2-스택-vs-큐-vs-덱)
  - [99-3. 성능 (시간 복잡도) 비교](#99-3-성능-시간-복잡도-비교)

# 1. 순차리스트 (배열(Array), 리스트(List))

## 1-1. 개요
[목차로 이동](#목차)

- 논리적인 순서와 물리적인 순서가 같은 구조
- 메모리에 연속적으로 저장됨
![](https://dojang.io/pluginfile.php/9454/mod_page/content/35/unit39-3.png)

## 1-2. 장점
[목차로 이동](#목차)

- 구현이 비교적 간단
- 접근 성능이 좋음 (인덱스를 사용하여 접근 가능)

## 1-3. 단점
[목차로 이동](#목차)

- 검색 성능이 좋지 않음 (전체 인덱스에 대한 검색 필요)
- 삽입, 삭제 성능이 좋지 않음 (논리적인 순서와 물리적인 순서가 같기 때문)

        <예시>
        lst = [A, B, C, D, E]
        - B와 C 사이에 값 N 추가 : [A, B, N, C, D, E] 로 변경
          이 때, C ~ E 까지의 값이 한 칸 씩 뒤로 이동
        - 값 C 삭제 : [A, B, D, E] 로 변경.
          이 때, D ~ E 까지의 값이 한 칸 씩 앞으로 이동

![](https://t1.daumcdn.net/cfile/tistory/231DCD385636E3C20F)

- 최초 크기 할당이 필요한 경우
  - 크기 변경이 불가능
  - 데이터 존재 유무와 상관없이 일정 크기의 메모리 공간 점유

## 1-4. 활용
[목차로 이동](#목차)

- 랜덤 샘플링 등의 랜덤 액세스가 많을 때

## 1-5. 파이썬 구현 예제
[목차로 이동](#목차)

- 리스트로 구현

```python
lst = [0, 1, 2, 3, 4, 5]
print(lst[3]) # search 3
```

# 2. 연결리스트 (Linked List; LL)

## 2-1. 개요 
[목차로 이동](#목차)

- 각 노드에 저장된 다음 노드의 주소에 의해 연결된 구조
- 노드 = 데이터 + 다음 노드의 주소 (node = data + next)
![](https://media.geeksforgeeks.org/wp-content/cdn-uploads/gq/2013/03/Linkedlist.png)

## 2-2. 장점
[목차로 이동](#목차)

- 길이의 가변성으로 효율적 메모리 사용
- 삽입, 삭제 성능이 좋음 (데이터 재구성 용이)
- 대용량 데이터 처리 적합

## 2-3. 단점 
[목차로 이동](#목차)

- 검색 성능이 좋지 않음 (특정 위치까지 순차적으로 순회)
- 메모리를 추가적으로 사용 (다음 노드의 주소를 저장하는 공간이 추가적으로 필요)

## 2-4. 종류
[목차로 이동](#목차)

1. 단순연결리스트 (Linked List; LL)

![](https://upload.wikimedia.org/wikipedia/commons/thumb/9/9c/Single_linked_list.png/400px-Single_linked_list.png)

2. 이중연결리스트 (Doubly Linked List; DLL)
- 양 방향 탐색 가능. 이전 노드에 접근하기 위해 리스트를 순회해야하는 단점을 해소
- 추가적인 메모리 공간이 필요하며, 코드가 복잡해짐.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/c/ca/Doubly_linked_list.png/400px-Doubly_linked_list.png)

3. 원형연결리스트 (Circular Linked List; CLL)
- 한 노드에서 다른 모든 노드로의 접근이 가능. (노드의 삽입, 삭제가 단순해짐.)
- 반복적인 순회에서 연결리스트의 끝을 체크해야할 필요가 없음
- head같은 메타데이터가 필요하지 않고, 이로 인해 시간, 메모리, 코드 모두 이득을 볼 수 있음
- 노드의 삽입, 삭제시 선행 노드의 포인터가 필요하다.
![](https://upload.wikimedia.org/wikipedia/commons/thumb/9/98/Circurlar_linked_list.png/400px-Circurlar_linked_list.png)

## 2-5. 활용
[목차로 이동](#목차)

- 목록에서 자주 추가하거나 제거해야하는 데이터로 작업할 때

## 2-6. 파이썬 구현 예제
[목차로 이동](#목차)

- 존재하는 내부 자료구조 없음. 필요하다면 직접 구현 필요

- 하지만, 파이썬에서 링크드 리스트는 의미가 크게 없는 게, 일반적인 리스트가 C++의 STL vector보다도 훨씬 쓰기 간편하며, 어떠한 타입의 데이터도 (심지어 튜플이나 리스트마저) 넣을 수 있고 동적으로 메모리 관리가 되기 때문에, 링크드 리스트의 의미가 크게 퇴색됨.

### 2-6-1. node 구현
[목차로 이동](#목차)
  - Data 필드 : 데이터 저장
  - Link 필드 : 노드의 다음 주소를 저장

```python
# Node class
class Node:
    # Function to initialize the node object
    def __init__(self, data):
        self.data = data  # Assign data
        self.next = None  # Initialize next as null
```

### 2-6-2. 연산 구현
[목차로 이동](#목차)
```python
# Linked List class
class LinkedList:
    # Function to initialize the Linked List object
    def __init__(self): 
        self.head = None
```

  1. 삽입 연산 [Insert]

     - 선행자의 링크 필드에 저장된 주소를 삽입할 노드의 링크 필드에 저장
     - 선행자의 링크 필드에 삽입할 노드의 주소를 저장
   
        => 예외 처리 : 선행자를 찾을 수 없는 경우

```python
# This function is in LinkedList class. 
# Inserts a new node after the given prev_node. This method is 
# defined inside LinkedList class shown above */ 
def insert(self, prev_node, new_data): 
  
    # 1. Create new node & 2. Put in the data 
    new_node = Node(new_data)
    
    # 3. check if the given prev_node exists 
    if prev_node is None: 
        new_node.next = self.head
        self.head = new_node
    else:
        # 4. Make next of new Node as next of prev_node
        new_node.next = prev_node.next
    
        # 5. make next of prev_node as new_node 
        prev_node.next = new_node
```

  2. 삭제 연산 [Delete]

     - 삭제할 노드의 링크 필드에 저장된 주소를 선행자의 링크 필드에 저장
     - 삭제할 노드를 삭제한다.
  
        => 예외 처리 : 삭제할 노드를 찾을 수 없는 경우

```python
# This function is in LinkedList class. 
# Given a reference to the head of a list and a key,
# delete the first occurence of key in linked list
def delete(self, key):
        
    # Store head node
    temp = self.head

    # If head node itself holds the key to be deleted
    if (temp is not None):
        if (temp.data == key):
            self.head = temp.next
            temp = None
            return

    # Search for the key to be deleted, keep track of the
    # previous node as we need to change 'prev.next'
    while(temp is not None):
        if temp.data == key:
            break
        prev = temp
        temp = temp.next

    # if key was not present in linked list
    if(temp == None):
        return

    # Unlink the node from linked list
    prev.next = temp.next

    temp = None
```

  - 검색 연산 [Search]

  1. 헤드부터 탐색 시작
  2. 노드의 링크 필드가 Null 일 때까지 탐색
  3. 노드의 데이터 필드가 검색 데이터와 동일하면 탐색 중지
  4. 해당 데이터의 노드 반환
  
        => 검색한 데이터가 리스트에 존재하지 않는 경우
        
        (헤드부터 검색을 하기 때문에 최악의 경우 리스트를 전부 검색해야 함)

```python
# This function is in LinkedList class. 
# This Function checks whether the value x present in the linked list 
def search(self, x):

    # Initialize current to head
    current = self.head

    # loop till current not equal to None
    while current != None:
        if current.data == x:
            return True # data found
            
        current = current.next
        
    return False # Data Not found
```

# 3. 스택 (Stack)

## 3-1. 개요
[목차로 이동](#목차)

- 가장 나중에 쌓은 데이터를 가장 먼저 뺄 수 있는 데이터 구조
- LIFO(Last-In, First-Out)방식을 사용
- 내부 프로세스 구조 함수의 동작 방식으로 사용
![](https://upload.wikimedia.org/wikipedia/commons/b/b4/Lifo_stack.png)

## 3-2. 장점
[목차로 이동](#목차)

- 구조가 단순하고, 구현이 쉬움
- 삽입, 삭제 성능이 좋음 (맨 위의 원소에 대해서만 고려하기 때문)

## 3-3. 단점
[목차로 이동](#목차)

- 검색 성능이 좋지 않음 (특정 데이터를 찾을 때까지 수행 필요)
- 맨 위의 원소만 접근 가능

## 3-4. 활용
[목차로 이동](#목차)

- 재귀 알고리즘에서 유용하게 사용
- 역추적을 해야할 때 (ex. 문서 작업 시 실행 취소)
- 괄호 검사
- 역순 문자열 만들기
- 후위 표기법으로의 변환

## 3-5. 파이썬 구현 예제
[목차로 이동](#목차)

```python
stack = []
stack.append(1) # 1 
stack.append(2) # 1 - 2 
stack.append(3) # 1 - 2 - 3 
stack.pop()     # 1 - 2     / get 3
stack.pop()     # 1         / get 2
```

# 4. 큐 (Queue)

## 4-1. 개요
[목차로 이동](#목차)

- 먼저 들어간 데이터가 먼저 나가는 데이터 구조
- FIFO(First-In, First-Out : 선입선출) 또는 LILO(Last-In, Last-Out) 방식을 사용
- 연결리스트 (Linked List; LL) 와 비슷
![](https://upload.wikimedia.org/wikipedia/commons/d/d3/Fifo_queue.png)

## 4-2. 장점
[목차로 이동](#목차)

- 삽입, 삭제 성능이 좋음 (양 끝의 원소에 대해서만 고려하기 때문)

## 4-3. 단점
[목차로 이동](#목차)

- 검색 성능이 좋지 않음 (특정 데이터를 찾을 때까지 수행 필요)
- 중간에 위치한 데이터로의 접근이 어려움

## 4-4. 활용
[목차로 이동](#목차)

- 데이터를 입력된 순서대로 처리해야 할 때
- BFS (너비 우선 탐색) 구현할 때
- 은행 또는 콜센터 대기 순서
- 프로세스 관리

## 4-5. 파이썬 구현 예제
[목차로 이동](#목차)

```python
from queue import Queue

q = Queue()
q.put(1) # 1 
q.put(2) # 1 - 2 
q.put(3) # 1 - 2 - 3 
q.get()  # 2 - 3     / get 1
q.get()  # 3         / get 2
```

# 5. 덱 (Deque)

## 5-1. 개요
[목차로 이동](#목차)

- Double-Ended Queue 의 줄임말
- front와 end에서 삭제와 삽입이 모두 가능
- 이중연결리스트 (Doubly Linked List; DLL) 와 비슷
- 연속적인 메모리를 기반으로 하는 '시퀀스 컨테이너'이기에 임의 접근 반복자 제공
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb6OjSc%2FbtqwdLZAnhq%2FQ2sUp0jmm4c6z6KuKvnlOK%2Fimg.png)

## 5-2. 장점
[목차로 이동](#목차)

- 삽입, 삭제 성능이 좋음 (양 끝의 원소에 대해서만 고려하기 때문)

## 5-3. 단점
[목차로 이동](#목차)

- 검색 성능이 좋지 않음 (특정 데이터를 찾을 때까지 수행 필요)
- 중간에 위치한 데이터로의 접근이 어려움

## 5-4. 활용
[목차로 이동](#목차)

- 앞과 뒤에서 삽입, 삭제가 자주 일어나는 경우
- 데이터의 개수가 가변적일 경우

## 5-5. 파이썬 구현 예제
[목차로 이동](#목차)

```python
from collections import deque

deq = deque()
deq.append(1)     # 1 
deq.append(2)     # 1 - 2 
deq.appendleft(3) # 3 - 1 - 2
deq.pop()         # 3 - 1     / get 2
deq.popleft()     # 1         / get 3
```
# 99. 정리

## 99-1. 순차리스트 vs 연결리스트
[목차로 이동](#목차)

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcnu8ag%2FbtqI58Bj81q%2FxWsXOndFYkCuaS3IEBpuO1%2Fimg.png)

## 99-2. 스택 vs 큐 vs 덱 
[목차로 이동](#목차)
- 순차리스트 또는 연결리스트로 구현 (대개는 연결리스트)

![](https://www.nakjunizm.com/2017/02/24/Queue_And_Deque/queue1.png)

## 99-3. 성능 (시간 복잡도) 비교
[목차로 이동](#목차)
- 순차리스트(배열) vs 연결리스트(LL, DLL) vs 스택 vs 큐

| \    | Array                                 | LL                                    | DLL                                   | Stack                                 | Queue                                 |
| ---- | ------------------------------------- | ------------------------------------- | ------------------------------------- | ------------------------------------- | ------------------------------------- |
| 접근 | <font color="green">빠름, O(1)</font> | 느림, O(n)                            | 느림, O(n)                            | 느림, O(n)                            | 느림, O(n)                            |
| 검색 | 느림, O(n)                            | 느림, O(n)                            | 느림, O(n)                            | 느림, O(n)                            | 느림, O(n)                            |
| 삽입 | 느림, O(n)                            | <font color="green">빠름, O(1)</font> | <font color="green">빠름, O(1)</font> | <font color="green">빠름, O(1)</font> | <font color="green">빠름, O(1)</font> |
| 삭제 | 느림, O(n)                            | <font color="green">빠름, O(1)</font> | <font color="green">빠름, O(1)</font> | <font color="green">빠름, O(1)</font> | <font color="green">빠름, O(1)</font> |